{"version":1,"windowDimensions":{"x":8,"y":46,"width":952,"height":500,"maximized":false},"grammars":{"grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/home/sguenther/Numerics/LSS_c++"],"buffers":[{"text":"#include <lsstypes.hpp>\n#include <Eigen/Sparse>\n#include <functions.hpp>\n#include <globalconst.hpp>\n#include <vector>\n#include <iostream>\n#include <structures.hpp>\n#include <math.h>\n#include <fstream>\n#include <sstream>\n#include <string>\n\n// include CoDiPack\n#include <codi.hpp>\n\n\n\n//Verbosity of the Program\nint verbose = 0;\n\n// Initial Lorenz rho for Reference\nRealType rho = 28.0;\n\n// Initial Van-der-Pol beta for Reference\nRealType beta_vdp = 2.0;\n\n\nint main(int nargs, char** args) {\n\n\n  // name output directory\n  std::ostringstream directorystream; \n  directorystream << \"data/N\"<< N << \"_\" << \"dtref\"<<dtref;\n  std::string directory = directorystream.str();\n\n\n\n\n  // create output directory\n  int err  = createoutputdir(directory,N,dtref);\n  if (err != 0)\n  {\n    std::cout<<\"ERROR while creating/replacing output directory\";\n    return -1;\n  }\n\n  // define variables \n  SolutionVars sol;\n  OptimVars optim;\n  LssVars lss;\n  Derivatives der;\n  ReferenceVars ref;\n  ConvergenceVarsTimeStepping conv_ts;\n\n\n  // INITIALIZATION of the solution variables\n  init_spacetime(sol);\n  initial_data(sol);\n  init_lss(lss);\n\n\n  // INITIALIZATION of Code Differentiation\n  #if TYPE_CODI\n    RealType::TapeType& tape = RealType::getGlobalTape();\n  #endif\n\n  // Open and prepare Output Files\n  // logfile\n  std::ostringstream filestream;\n  filestream << directory << \"/outlog.txt\";\n  const std::string&tmp = filestream.str();\n  const char* filenamechar = tmp.c_str();\n  std::ofstream outlogfile;\n  outlogfile.open(filenamechar);\n  // write parameters to outlogfile\n  outlogfile << \"Problem Parameters:\\n\";\n  // outlogfile << format(\"rho %4.3f sigma %4.3f beta %4.3f\", \n  //                       getValue(rho), getValue(sigma), getValue(beta)) <<\"\\n\";\n  outlogfile << format (\"beta_vdp %4.3f\", getValue(beta_vdp)) <<\"\\n\";\n  outlogfile << format(\"a %4.3f mu %1.4e\", getValue(a), getValue(mu)) <<\"\\n\";\n  outlogfile << \"\\nDiscretization:\\n\";\n  outlogfile << format(\"N %d dtref %4.3f\", N, getValue(dtref))<<\"\\n\";\n  outlogfile << format(\"M %d dx %4.3f\", M, getValue(dx))<<\"\\n\";\n  outlogfile << \"\\nLSS: \\n\";\n  outlogfile << format(\"alpha %4.2f\\n\", getValue(alpha));\n  outlogfile << format(\"abstol_lss %1.8e\\n\", getValue(abstol_lss));\n  outlogfile << \"\\nOptimization:\\n\";\n  outlogfile << format(\"abstol_adj %1.8e\\n\", getValue(abstol_adj));\n  outlogfile << format(\"abstol_grad %1.8e\\n\", getValue(abstol_grad));\n  outlogfile << format(\"stepsize %1.8e\\n\", getValue(stepsize_design));\n\n\n  // Open and prepare Optim File\n  std::ostringstream filestreamx;\n  filestreamx << directory << \"/optim.dat\";\n  const std::string&tmpx = filestreamx.str();\n  const char* filenamecharx = tmpx.c_str();\n  std::ofstream optimfile;\n  optimfile.open(filenamecharx);\n  optimfile << \"#Optim Parameters: \\n\";\n  // optimfile << format(\"#rho reference %4.8f\", getValue(rho)) <<\"\\n\\n\";\n  optimfile << format(\"#beta_vdp reference %4.8f\", getValue(beta_vdp)) <<\"\\n\\n\";\n  optimfile << \"#iter  Average       Objective            GradientNorm         \";\n  optimfile << \"LSSresiduum          ADresiduum\\n\";\n  //File for Residuals over time \n  std::ostringstream filestreamy;\n  filestreamy << directory << \"/residuals_over_time.dat\";\n  const std::string&resfilestring = filestreamy.str();\n  const char* filenamechary = resfilestring.c_str();\n  std::ofstream residualfile;\n  residualfile.open(filenamechary);\n\n    \n  // compute reference solution with classical time-stepping scheme\n  if (verbose) std::cout << \"Computing reference solution...\\n\";\n  outlogfile << \"Computing reference solution...\\n\";\n  err = time_stepping(sol, optim, conv_ts);\n  if (err!=0)\n  {\n    std::cout<<\"ERROR while computing a reference solution!\\n\";\n    outlogfile<<\"ERROR while computing a reference solution!\\n\";\n    return -1;\n  } else \n  {\n    std::cout << \"Reference Solution OK! \\n\";\n    outlogfile << \"Reference Solution OK! \\n\";\n  }\n\n  //write reference solution to file\n  err = writesolution(sol, directory, \"_ref.dat\");\n  if (err!=0)\n  {\n    std::cout<< \"ERROR: Couldn't write reference file.\\n\";\n    return -1;\n  }\n\n  //copy solution to reference variables\n  copy_solution(sol, ref);\n\n\n\n\n  //\n  // LSS\n  //\n  //Vary parameter !\n  // optim.amp +=  0.5;  \n  // rho = rho + 1.0;\n  \n  beta_vdp += 1.0;\n\n\n  \n  //  output LSS setting\n  std::cout  << format(\"alpha %4.3f\", getValue(alpha))<< std::endl;\n  std::cout<<\"Starting LSS...\\n\";\n  outlogfile<<\"Starting LSS...\\n\";\n  #if (TYPE_CODI == 1)  \n    std::cout<< \"LSS execution mode: ADJOINT\\n\\n\";\n    outlogfile << \"LSS execution mode: ADJOINT\"<<std::endl<<std::endl;\n  #elif (TYPE_CODI == 2)\n    std::cout<< \"LSS execution mode: OPTIMIZATION\\n\\n\";\n    outlogfile << \"LSS execution mode: OPTIMIZATION\"<<std::endl<<std::endl;\n  #else \n    std::cout<< \"LSS execution mode: PRIMAL\\n\\n\";\n    outlogfile << \"LSS execution mode: PRIMAL\"<<std::endl<<std::endl;   \n  #endif\n  std::cout << format(\"amp = %4.8f\", getValue(optim.amp))<<\"\\n\";\n  outlogfile << format(\"amp = %4.8f\", getValue(optim.amp))<<\"\\n\";\n  // std::cout << format(\"rho = %4.8f\", getValue(rho))<<\"\\n\";\n  // outlogfile << format(\"rho = %4.8f\", getValue(rho))<<\"\\n\";\n  std::cout << format(\"beta_vdp = %4.8f\", getValue(beta_vdp))<<\"\\n\";\n  outlogfile << format(\"beta_vdp = %4.8f\", getValue(beta_vdp))<<\"\\n\";\n\n  // LSS Newton-loop\n  for (int iter = 0; iter < 400; iter++)\n  // for (int iter = 0; iter < maxiter_lss; iter++)\n  {\n\n    #if TYPE_CODI\n        // Activate Tape \n        tape.setActive();\n\n        //Register input variables and store index of state for the tape\n        std::vector<int> stateindex;\n        stateindex.reserve(N*M + 3*N + (N-1)*M + 4*(N-1));\n        RegisterInputStoreIndex(sol, lss, tape, stateindex);\n    #endif\n\n    // compute LSS Residuum;\n    LSSresiduum(sol, ref, optim, der, lss);\n\n    // Check convergence of LSS\n    RealType r1norm = linalg_norm_square(lss.r1.arr, lss.r1.dimx * lss.r1.dimy );\n    RealType r2norm = linalg_norm_square(lss.r2, N-1 );\n    RealType r3norm = linalg_norm_square(lss.r3.arr, lss.r3.dimx * lss.r3.dimy );\n    optim.lss_res = sqrt(r1norm + r2norm + r3norm);\n\n\n    // Output residuals\n    #if TYPE_CODI \n      std::cout << format(\"iter, aver, cost, grad, lss_res, ad_res %2i %1.14e %1.14e %1.14e %1.14e %1.14e\\n\",\n            iter, getValue(optim.average), getValue(optim.cost), getValue(optim.red_grad),\n            getValue(optim.lss_res), getValue(optim.ad_res) );\n      optimfile << format(\"%2i %1.14e %1.14e %1.14e %1.14e %1.14e\\n\",\n            iter, getValue(optim.average), getValue(optim.cost), getValue(optim.red_grad),\n            getValue(optim.lss_res), getValue(optim.ad_res) );\n    #else\n      std::cout << format(\"iter, resnorm, R1, R2, R3 %2i %1.14e %1.14e %1.14e %1.14e\", \n            iter, getValue(optim.lss_res), getValue(sqrt(r1norm)), \n            getValue(sqrt(r2norm)), getValue(sqrt(r3norm))) << std::endl;\n    #endif\n    outlogfile << format(\"iter, resnorm, R1, R2, R3 %2i %1.14e %1.14e %1.14e %1.14e\",  \n          iter, getValue(optim.lss_res), getValue(sqrt(r1norm)), \n          getValue(sqrt(r2norm)), getValue(sqrt(r3norm))) << \"\\n\"; \n    outlogfile << format(\"iter, aver, cost, grad, lss_res, ad_res %2i %1.14e %1.14e %1.14e %1.14e %1.14e\\n\",\n            iter, getValue(optim.average), getValue(optim.cost), getValue(optim.red_grad),\n            getValue(optim.lss_res), getValue(optim.ad_res) );\n\n    // Write residuals over time to file\n    #if TYPE_CODI \n      tape.setPassive();\n    #endif\n    for (int ts = 0; ts < N-1; ts++)\n    {\n      RealType tsnorm = 0.0;\n      for (int m=0; m<M+dimode; m++)\n      {\n        tsnorm += pow(lss.r3(ts,m),2);\n      }\n      tsnorm = sqrt(tsnorm);\n      residualfile << format(\"%1.14e \", getValue(tsnorm));\n    }\n    residualfile << \"\\n\"; \n    #if TYPE_CODI \n      tape.setActive();\n    #endif\n\n    //stopping criterion\n    #if TYPE_CODI\n      if (   (optim.lss_res < abstol_lss) \n          && (optim.ad_res < abstol_adj)\n          && (optim.redgrad_norm < abstol_grad)  \n          && (iter > 2) )\n    #else\n      if (   (optim.lss_res < abstol_lss) )\n    #endif\n    {\n        std::cout << \"\\nSolver converged!!\" << std::endl\n                  << \"Be happy and go home!\\n\" << std::endl;\n        outlogfile << \"\\nSolver converged!!\\n\"\n                   << \"Be happy and go home! \\n\\n\";\n        break;\n    }\n    \n    // Set up Sparse Schurcomplement Matrix  \n    if (verbose) std::cout << \"Setting up SchurMatrix...\" << std::endl;\n    int L = (N-1)*(M+dimode); //Dimension of the Matrix (N-1)*(M+dimode) x (N-1)*(M+dimode)\n    Eigen::SparseMatrix<RealType> Schur(L,L);\n    FillSparseSchurmatrix(sol, optim, der, Schur);\n\n\n    // Set up right hand side of linear system\n    if (verbose) std::cout << \"Setting up RHS...\" << std::endl;\n    Eigen::Matrix<RealType, Eigen::Dynamic, 1> rhs(L);\n    FillRHS(sol,optim,der,lss,rhs);\n\n\n    \n    // Solve the linear Schur system with EIGEN\n    #if TYPE_CODI\n        tape.setPassive();\n    #endif\n    Eigen::Matrix<RealType, Eigen::Dynamic, 1> deltaw(L);\n    Eigen::SimplicialLDLT<Eigen::SparseMatrix<RealType> > solver;\n    if (verbose) std::cout << \"solver.compute...\" << std::endl;\n    solver.compute(Schur);\n    if (verbose) std::cout << \"solver.solve...\" << std::endl;\n    deltaw = solver.solve(rhs);\n    // if (verbose) std::cout << \"Solver info: \" << solver.info() << std::endl;\n    if (solver.info() != 0)\n    {\n      std::cout << \"ERROR: solving linear system failed!\\n\";\n      outlogfile<< \"ERROR: solving linear system failed!\" << std::endl;\n    }\n\n    #if TYPE_CODI\n        //register solution of linear system as input for the tape delta w\n        for (int l=0; l<L; l++)\n        {\n          tape.registerInput(deltaw(l));\n        }\n        //push external linear system solver function to the tape\n        // first: add data that is needed inside the external function\n        codi::DataStore *data = new codi::DataStore;\n        data->addData(&deltaw);\n        data->addData(&rhs);\n        data->addData(&Schur);\n        data->addData(&solver);\n        tape.pushExternalFunction(&Solve_Reverse, data, &Delete);\n        \n        // set tape active for further computation\n        tape.setActive();\n    #endif\n\n    //Update State Variables\n    if (verbose) std::cout << \"Updating Variables...\" << std::endl;\n    UpdateLssVariables(sol, optim, der, lss, deltaw);\n\n    //update the time scale\n    for (int ts=1; ts < N; ts++)\n    {\n      sol.t[ts] = sol.t[ts-1] + sol.dt[ts-1];\n    }\n\n    // compute objective function\n    Costfunction(sol, optim);\n    std::cout << format(\"Average, Cost %1.14e %1.14e\",\n                        getValue(optim.average), getValue(optim.cost)) <<std::endl;\n    outlogfile<< format(\"Objective Function %1.14e\", getValue(optim.cost)) << \"\\n\";\n\n    #if TYPE_CODI\n        // Deactivate tape\n        tape.setPassive();\n        \n        //Set Gradients for Tape evaluation\n        SetGradientAdjointsForTapeEval(sol, lss, optim);\n        \n        // Evaluate the tape\n        if (verbose) std::cout << \"Evaluating Tape...\" <<std::endl;\n        tape.evaluate();\n        \n        // Update the adjoint state and \n        // Check Adjoint Convergence  \n        UpdateAdjointCheckConvergence(optim, tape, stateindex);\n        // std::cout << format(\"Adjoint residuum %1.14e\", getValue(optim.ad_res))<<std::endl;\n        outlogfile<< format(\"Adjoint residuum %1.14e\", getValue(optim.ad_res))<<\"\\n\";\n\n        // Get reduced Gradient\n        optim.red_grad = beta_vdp.getGradient();\n        optim.redgrad_norm = sqrt(pow(optim.red_grad, 2));\n        // std::cout << format(\"Gradient %1.14e\", getValue(optim.red_grad)) << std::endl;\n        outlogfile<< format(\"Gradient %1.14e\", getValue(optim.red_grad)) << \"\\n\";\n\n        //reset the tape\n        tape.reset();\n    #endif\n\n\n\n\n\n    #if (TYPE_CODI==2)\n      // update the design\n      if (iter>2)\n      {\n        beta_vdp = beta_vdp - optim.stepsize * optim.hessian * optim.red_grad;\n        // rho = rho - optim.stepsize * optim.hessian * optim.red_grad;\n        std::cout << format(\"beta %1.14e \\n\", getValue(beta_vdp));\n        outlogfile<< format(\"beta %1.14e \\n\", getValue(beta_vdp));\n        optimfile << format(\"#beta %1.14e \\n\", getValue(beta_vdp));\n      }\n    #endif\n\n\n    // //write intermediate solution\n    // std::ostringstream iterstream;\n    // iterstream << \"_iter\" << iter;\n    // const std::string&tmpu = iterstream.str();\n    // const char* iterchar = tmpu.c_str();\n    // err = writesolution(sol, directory, iterchar);\n\n  } //end of lss loop\n\n\n  //write solution to file\n  err = writesolution(sol, directory, \"_final.dat\");\n  if (err!=0)\n  {\n    std::cout<< \"ERROR: Couldn't write final solution file.\\n\";\n    outlogfile<< \"ERROR: Couldn't write final solution file.\\n\";\n    return -1;\n  }\n\n\n  // close files\n  outlogfile.close();\n  optimfile.close();\n  residualfile.close();\n\n  // Transpose residuum file\n  std::string command = \"sh ./transposefile.sh \" + resfilestring + \" > \"\n                         + resfilestring + \"_transpose\";\n  std::cout << command << std::endl;\n  err=system(command.c_str());\n  if (err!=0)\n  {\n    std::cout << \"ERROR while transposing residuum file\" <<std::endl;\n    outlogfile<< \"ERROR while transposing residuum file.\\n\";\n\n  }\n\n  return 0;\n}\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":11,"column":0},"end":{"row":11,"column":0}},"properties":{"type":"selection","goalScreenRange":null,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/sguenther/Numerics/LSS_c++/src/lorenz.cpp","digestWhenLastPersisted":"cec803bf4bd8582d51735faa7def48a9d8a97826","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","preferredLineEnding":null,"deserializer":"TextBuffer","version":4},{"text":"","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":0,"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":1,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","preferredLineEnding":null,"deserializer":"TextBuffer","version":4}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"Pane","id":3,"items":[{"deserializer":"TextEditor","id":4,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":5,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":8,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":9,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/home/sguenther/Numerics/LSS_c++/src/lorenz.cpp","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":28,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":29,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"}],"activeItemURI":"/home/sguenther/Numerics/LSS_c++/src/lorenz.cpp","focused":true,"flexScale":1},"activePaneId":3},"packagesWithActiveGrammars":["language-c","language-hyperlink","language-todo"],"destroyedItemURIs":[]},"packageStates":{"fuzzy-finder":{"/home/sguenther/Numerics/LSS_c++/src/lorenz.cpp":1452688217427},"metrics":{"sessionLength":98679},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/home/sguenther/Numerics/LSS_c++":{"isExpanded":true,"entries":{".git":{"isExpanded":false,"entries":{}},"build":{"isExpanded":false,"entries":{}},"data":{"isExpanded":false,"entries":{}},"data_lorenz":{"isExpanded":false,"entries":{}},"data_vdp":{"isExpanded":false,"entries":{}},"include":{"isExpanded":false,"entries":{}},"src":{"isExpanded":true,"entries":{}}}}},"selectedPath":"/home/sguenther/Numerics/LSS_c++/src/lorenz.cpp","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}},"fullScreen":false}